{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from \"react\";\nimport { Grid, Form, Button, Input, Message, Select, Icon, Table } from \"semantic-ui-react\";\nimport Layout from \"../../components/Layout\";\nimport tokenMintFactory from \"../../ethereum/tokenMintFactory\";\nimport web3 from \"../../ethereum/web3\";\nimport { Router } from \"../../routes\";\n\nvar TokenMintNew = /*#__PURE__*/function (_Component) {\n  _inherits(TokenMintNew, _Component);\n\n  var _super = _createSuper(TokenMintNew);\n\n  function TokenMintNew() {\n    var _this;\n\n    _classCallCheck(this, TokenMintNew);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      tokenName: \"\",\n      tokenSymbol: \"\",\n      wholeTokens: \"0\",\n      decimals: \"18\",\n      errorMessage: \"\",\n      calculateErrorMessage: \"\",\n      tokensPerBlock: \"1000\",\n      potentialInvestors: \"100\",\n      projectedProfits: \"0\",\n      initialPoolPercentage: \"10\",\n      minimumReturn: \"10\",\n      blocksToStabilize: \"75\",\n      blockPricingInput1: \"2\",\n      blockPricingInput2: \"#\",\n      blockPricingOperand: \"*\",\n      coinsToStabilize: \"\",\n      mintFeePostStable: \"0.1\",\n      s2: \"\",\n      s3: \"\",\n      s4: \"\",\n      s5: \"\",\n      s1ProfitsAtStabilization: \"\",\n      s2ProfitsAtStabilization: \"\",\n      s3ProfitsAtStabilization: \"\",\n      s4ProfitsAtStabilization: \"\",\n      s5ProfitsAtStabilization: \"\",\n      s1BlocksToProfit: \"\",\n      s2BlocksToProfit: \"\",\n      s3BlocksToProfit: \"\",\n      s4BlocksToProfit: \"\",\n      s5BlocksToProfit: \"\",\n      s1BlockCost: \"\",\n      s2BlockCost: \"\",\n      s3BlockCost: \"\",\n      s4BlockCost: \"\",\n      s5BlockCost: \"\",\n      loading: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"calculate\", function (event) {\n      event.preventDefault();\n      var sampleSize = parseInt(parseInt(_this.state.potentialInvestors) / 5);\n      var numCoinsToStabilize = parseFloat(_this.state.blocksToStabilize) * parseFloat(_this.state.tokensPerBlock);\n      var sample2 = sampleSize < 2 ? 2 : sampleSize;\n      var sample3 = sampleSize * 2 < 3 ? 3 : sampleSize * 2;\n      var sample4 = sampleSize * 3 < 4 ? 4 : sampleSize * 3;\n      var sample5 = parseInt(_this.state.potentialInvestors) < 5 ? 5 : parseInt(_this.state.potentialInvestors);\n\n      _this.setState({\n        coinsToStabilize: numCoinsToStabilize,\n        s2: sample2,\n        s3: sample3,\n        s4: sample4,\n        s5: sample5\n      });\n\n      var operand = _this.state.blockPricingOperand;\n      var pricingInput1 = _this.state.blockPricingInput1 == \"#\" ? \"#\" : parseFloat(_this.state.blockPricingInput1);\n      var pricingInput2 = _this.state.blockPricingInput2 == \"#\" ? \"#\" : parseFloat(_this.state.blockPricingInput2);\n      var startingPrice = parseFloat(_this.state.startingPrice);\n      var tokensPerBlock = parseInt(_this.state.tokensPerBlock);\n\n      function getCost(blockNumber) {\n        console.log(\"Block #: \", blockNumber);\n        console.log(\"Input 1: \", pricingInput1);\n        console.log(\"operand: \", operand);\n        console.log(\"Input 2: \", pricingInput2);\n        console.log(\"Starting price: \", startingPrice);\n        console.log(\"tokens per block: \", tokensPerBlock);\n        var adjustment = 0;\n\n        switch (operand) {\n          case \"*\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber * pricingInput2;\n            } else {\n              adjustment = pricingInput1 * blockNumber;\n            }\n\n            break;\n\n          case \"^\":\n            if (pricingInput1 == \"#\") {\n              adjustment = Math.pow(blockNumber, pricingInput2);\n            } else {\n              adjustment = Math.pow(pricingInput1, blockNumber);\n            }\n\n            break;\n\n          case \"+\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber + pricingInput2;\n            } else {\n              adjustment = pricingInput1 + blockNumber;\n            }\n\n            break;\n\n          case \"-\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber - pricingInput2;\n            } else {\n              adjustment = pricingInput1 - blockNumber;\n            }\n\n            break;\n\n          case \"/\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber / pricingInput2;\n            } else {\n              adjustment = pricingInput1 / blockNumber;\n            }\n\n            break;\n\n          default:\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber * pricingInput2;\n            } else {\n              adjustment = pricingInput1 * blockNumber;\n            }\n\n            break;\n        }\n\n        var blockCost = startingPrice * tokensPerBlock * adjustment;\n        return blockCost;\n      }\n\n      _this.setState({\n        s1BlockCost: getCost(1),\n        s2BlockCost: getCost(sample2),\n        s3BlockCost: getCost(sample3),\n        s4BlockCost: getCost(sample4),\n        s5BlockCost: getCost(sample5)\n      });\n\n      var targetPrice = parseInt(_this.state.potentialInvestors) > 5 ? 5 * parseFloat(_this.state.s5BlockCost) * parseFloat(_this.state.minimumReturn) : parseInt(_this.state.potentialInvestors) * parseFloat(_this.state.s5BlockCost) * parseFloat(_this.state.minimumReturn);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onSubmit\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(event) {\n        var accounts;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                event.preventDefault();\n\n                _this.setState({\n                  loading: true,\n                  errorMessage: \"\"\n                });\n\n                _context.prev = 2;\n                _context.next = 5;\n                return web3.eth.getAccounts();\n\n              case 5:\n                accounts = _context.sent;\n                _context.next = 8;\n                return tokenMintFactory.methods.createToken(_this.state.tokenName, _this.state.tokenSymbol, _this.state.wholeTokens, _this.state.decimals).send({\n                  from: accounts[0]\n                });\n\n              case 8:\n                Router.pushRoute(\"/funding\");\n                _context.next = 14;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](2);\n\n                _this.setState({\n                  errorMessage: _context.t0.message\n                });\n\n              case 14:\n                _this.setState({\n                  loading: false\n                });\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 11]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    return _this;\n  }\n\n  _createClass(TokenMintNew, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      return __jsx(Layout, {\n        page: \"create\"\n      }, __jsx(Grid, null, __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h2\", null, \"Create a Mintable ERC-20 Token\"))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h3\", null, \"Token Details\"))), __jsx(Form, {\n        onSubmit: this.onSubmit,\n        error: !!this.state.errorMessage\n      }, __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n        widths: \"equal\"\n      }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Token Name\"), __jsx(Input, {\n        value: this.state.tokenName,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            tokenName: event.target.value\n          });\n        }\n      })), __jsx(Form.Field, null, __jsx(\"label\", null, \"Token Symbol\"), __jsx(Input, {\n        value: this.state.tokenSymbol,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            tokenSymbol: event.target.value\n          });\n        }\n      }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n        widths: \"equal\"\n      }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Decimals\"), __jsx(Input, {\n        value: this.state.decimals,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            decimals: event.target.value\n          });\n        }\n      })), __jsx(Form.Field, null, __jsx(\"label\", null, \"Tokens Per Block\"), __jsx(Input, {\n        value: this.state.tokensPerBlock,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            tokensPerBlock: event.target.value\n          });\n        }\n      }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Message, {\n        error: true,\n        header: \"Oops!\",\n        content: this.state.errorMessage\n      }), __jsx(\"br\", null)))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h3\", null, \"Profit Calculator\"))), __jsx(Form, {\n        onSubmit: this.calculate,\n        error: !!this.state.calculateErrorMessage\n      }, __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n        widths: \"equal\"\n      }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Potential Investors\"), __jsx(Input, {\n        value: this.state.potentialInvestors,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            potentialInvestors: event.target.value\n          });\n        }\n      }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n        widths: \"equal\"\n      }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Projected Profits\"), __jsx(Input, {\n        label: \"ether\",\n        labelPosition: \"right\",\n        value: this.state.projectedProfits,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            projectedProfits: event.target.value\n          });\n        }\n      })), __jsx(Form.Field, null, __jsx(\"label\", null, \"% of Profits to Pool\"), __jsx(Input, {\n        label: \"%\",\n        labelPosition: \"right\",\n        value: this.state.initialPoolPercentage,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            initialPoolPercentage: event.target.value\n          });\n        }\n      }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n        widths: \"equal\"\n      }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Minimum Return\"), __jsx(Input, {\n        label: \"X\",\n        labelPosition: \"right\",\n        value: this.state.minimumReturn,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            minimumReturn: event.target.value\n          });\n        }\n      })), __jsx(Form.Field, null, __jsx(\"label\", null, \"Blocks to Stabilize\"), __jsx(Input, {\n        value: this.state.blocksToStabilize,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            blocksToStabilize: event.target.value\n          });\n        }\n      }))), __jsx(\"br\", null))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n        inline: true\n      }, __jsx(Form.Field, {\n        label: \"Mint Fee Pricing:\",\n        control: \"select\",\n        value: this.state.blockPricingInput1,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            blockPricingInput1: event.target.value,\n            blockPricingInput2: event.target.value != \"#\" ? \"#\" : _this2.state.blockPricingInput2\n          });\n        }\n      }, __jsx(\"option\", {\n        value: \"#\"\n      }, \"Number of Blocks\"), __jsx(\"option\", {\n        value: \"0.5\"\n      }, \"0.5\"), __jsx(\"option\", {\n        value: \"1\"\n      }, \"1\"), __jsx(\"option\", {\n        value: \"2\"\n      }, \"2\"), __jsx(\"option\", {\n        value: \"3\"\n      }, \"3\"), __jsx(\"option\", {\n        value: \"4\"\n      }, \"4\"), __jsx(\"option\", {\n        value: \"5\"\n      }, \"5\"), __jsx(\"option\", {\n        value: \"6\"\n      }, \"6\"), __jsx(\"option\", {\n        value: \"7\"\n      }, \"7\"), __jsx(\"option\", {\n        value: \"8\"\n      }, \"8\"), __jsx(\"option\", {\n        value: \"9\"\n      }, \"9\"), __jsx(\"option\", {\n        value: \"10\"\n      }, \"10\"), __jsx(\"option\", {\n        value: \"20\"\n      }, \"20\"), __jsx(\"option\", {\n        value: \"30\"\n      }, \"30\"), __jsx(\"option\", {\n        value: \"40\"\n      }, \"40\"), __jsx(\"option\", {\n        value: \"50\"\n      }, \"50\"), __jsx(\"option\", {\n        value: \"60\"\n      }, \"60\"), __jsx(\"option\", {\n        value: \"70\"\n      }, \"70\"), __jsx(\"option\", {\n        value: \"80\"\n      }, \"80\"), __jsx(\"option\", {\n        value: \"90\"\n      }, \"90\"), __jsx(\"option\", {\n        value: \"100\"\n      }, \"100\"), __jsx(\"option\", {\n        value: \"200\"\n      }, \"200\"), __jsx(\"option\", {\n        value: \"300\"\n      }, \"300\"), __jsx(\"option\", {\n        value: \"400\"\n      }, \"400\"), __jsx(\"option\", {\n        value: \"500\"\n      }, \"500\"), __jsx(\"option\", {\n        value: \"600\"\n      }, \"600\"), __jsx(\"option\", {\n        value: \"700\"\n      }, \"700\"), __jsx(\"option\", {\n        value: \"800\"\n      }, \"800\"), __jsx(\"option\", {\n        value: \"900\"\n      }, \"900\"), __jsx(\"option\", {\n        value: \"1000\"\n      }, \"1000\")), __jsx(Form.Field, {\n        control: \"select\",\n        value: this.state.blockPricingOperand,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            blockPricingOperand: event.target.value\n          });\n        }\n      }, __jsx(\"option\", {\n        value: \"*\"\n      }, \"*\"), __jsx(\"option\", {\n        value: \"^\"\n      }, \"^\"), __jsx(\"option\", {\n        value: \"+\"\n      }, \"+\"), __jsx(\"option\", {\n        value: \"-\"\n      }, \"-\"), __jsx(\"option\", {\n        value: \"/\"\n      }, \"/\")), __jsx(Form.Field, {\n        control: \"select\",\n        value: this.state.blockPricingInput2,\n        onChange: function onChange(event) {\n          return _this2.setState({\n            blockPricingInput2: event.target.value,\n            blockPricingInput1: event.target.value != \"#\" ? \"#\" : _this2.state.blockPricingInput1\n          });\n        }\n      }, __jsx(\"option\", {\n        value: \"#\"\n      }, \"Number of Blocks\"), __jsx(\"option\", {\n        value: \"0.5\"\n      }, \"0.5\"), __jsx(\"option\", {\n        value: \"1\"\n      }, \"1\"), __jsx(\"option\", {\n        value: \"2\"\n      }, \"2\"), __jsx(\"option\", {\n        value: \"3\"\n      }, \"3\"), __jsx(\"option\", {\n        value: \"4\"\n      }, \"4\"), __jsx(\"option\", {\n        value: \"5\"\n      }, \"5\"), __jsx(\"option\", {\n        value: \"6\"\n      }, \"6\"), __jsx(\"option\", {\n        value: \"7\"\n      }, \"7\"), __jsx(\"option\", {\n        value: \"8\"\n      }, \"8\"), __jsx(\"option\", {\n        value: \"9\"\n      }, \"9\"), __jsx(\"option\", {\n        value: \"10\"\n      }, \"10\"))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Button, {\n        color: \"teal\",\n        style: {\n          marginBottom: \"20px\"\n        }\n      }, \"Calculate\")))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h3\", null, \"Summary:\"), __jsx(\"p\", null, \"This mint fee of\", \" \", __jsx(\"strong\", null, \"(\", this.state.blockPricingInput1 == \"#\" ? \"Block #\" : this.state.blockPricingInput1, \" \", this.state.blockPricingOperand, \" \", this.state.blockPricingInput2 == \"#\" ? \"Block #\" : this.state.blockPricingInput2, \")\"), \" \", \"will be in effect for the first\", \" \", __jsx(\"strong\", null, this.state.blocksToStabilize, \" blocks (\", this.state.coinsToStabilize, \" tokens)\"), \".\"), __jsx(\"p\", null, \"The price will stabilize at \", __jsx(\"strong\", null, \"xxx.xx ether\"), \" per token with a stable mint fee of \", __jsx(\"strong\", null, \"xxx.xx ETH\"), \".\"), __jsx(\"p\", null, \"Assuming \", __jsx(\"strong\", null, this.state.initialPoolPercentage, \"%\"), \" of profits of \", __jsx(\"strong\", null, this.state.projectedProfits, \" ether\"), \" \", \"are contributed to the liquidity pool:\"))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Table, {\n        celled: true\n      }, __jsx(Table.Header, null, __jsx(Table.Row, null, __jsx(Table.HeaderCell, null, \"Block\"), __jsx(Table.HeaderCell, null, \"Cost\"), __jsx(Table.HeaderCell, null, \"Blocks to Break Even\"), __jsx(Table.HeaderCell, null, \"Blocks to \", this.state.minimumReturn, \"X\"))), __jsx(Table.Body, null, __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #1\"), __jsx(Table.Cell, null, this.state.s1BlockCost, \" ETH\"), __jsx(Table.Cell, null, this.state.s1BlocksToProfit), __jsx(Table.Cell, null, \"xxx\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s2), __jsx(Table.Cell, null, this.state.s2BlockCost, \" ETH\"), __jsx(Table.Cell, null, this.state.s2BlocksToProfit), __jsx(Table.Cell, null, \"xxx\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s3), __jsx(Table.Cell, null, this.state.s3BlockCost, \" ETH\"), __jsx(Table.Cell, null, this.state.s3BlocksToProfit), __jsx(Table.Cell, null, \"xxx\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s4), __jsx(Table.Cell, null, this.state.s4BlockCost, \" ETH\"), __jsx(Table.Cell, {\n        negative: true\n      }, this.state.s4BlocksToProfit), __jsx(Table.Cell, {\n        negative: true\n      }, \"Too Many\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s5), __jsx(Table.Cell, null, this.state.s5BlockCost, \" ETH\"), __jsx(Table.Cell, {\n        negative: true\n      }, this.state.s5BlocksToProfit), __jsx(Table.Cell, {\n        negative: true\n      }, \"Too Many\"))))))), __jsx(\"br\", null));\n    }\n  }]);\n\n  return TokenMintNew;\n}(Component);\n\nexport default TokenMintNew;","map":null,"metadata":{},"sourceType":"module"}