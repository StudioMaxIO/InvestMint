{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from \"react\";\nimport { Grid, Form, Button, Input, Message, Select, Icon, Table } from \"semantic-ui-react\";\nimport Layout from \"../../components/Layout\";\nimport tokenMintFactory from \"../../ethereum/tokenMintFactory\";\nimport web3 from \"../../ethereum/web3\";\nimport { Router } from \"../../routes\";\n\nclass TokenMintNew extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      tokenName: \"\",\n      tokenSymbol: \"\",\n      wholeTokens: \"0\",\n      decimals: \"18\",\n      errorMessage: \"\",\n      calculateErrorMessage: \"\",\n      tokensPerBlock: \"1000\",\n      potentialInvestors: \"100\",\n      projectedProfits: \"0\",\n      initialPoolPercentage: \"10\",\n      minimumReturn: \"10\",\n      blocksToStabilize: \"75\",\n      blockPricingInput1: \"2\",\n      blockPricingInput2: \"#\",\n      blockPricingOperand: \"*\",\n      coinsToStabilize: \"\",\n      mintFeePostStable: \"0.1\",\n      s2: \"\",\n      s3: \"\",\n      s4: \"\",\n      s5: \"\",\n      s1ProfitsAtStabilization: \"\",\n      s2ProfitsAtStabilization: \"\",\n      s3ProfitsAtStabilization: \"\",\n      s4ProfitsAtStabilization: \"\",\n      s5ProfitsAtStabilization: \"\",\n      s1BlocksToProfit: \"\",\n      s2BlocksToProfit: \"\",\n      s3BlocksToProfit: \"\",\n      s4BlocksToProfit: \"\",\n      s5BlocksToProfit: \"\",\n      s1BlockCost: \"\",\n      s2BlockCost: \"\",\n      s3BlockCost: \"\",\n      s4BlockCost: \"\",\n      s5BlockCost: \"\",\n      loading: false\n    });\n\n    _defineProperty(this, \"calculate\", event => {\n      event.preventDefault();\n      var sampleSize = parseInt(parseInt(this.state.potentialInvestors) / 5);\n      var numCoinsToStabilize = parseFloat(this.state.blocksToStabilize) * parseFloat(this.state.tokensPerBlock);\n      var sample2 = sampleSize < 2 ? 2 : sampleSize;\n      var sample3 = sampleSize * 2 < 3 ? 3 : sampleSize * 2;\n      var sample4 = sampleSize * 3 < 4 ? 4 : sampleSize * 3;\n      var sample5 = parseInt(this.state.potentialInvestors) < 5 ? 5 : parseInt(this.state.potentialInvestors);\n      this.setState({\n        coinsToStabilize: numCoinsToStabilize,\n        s2: sample2,\n        s3: sample3,\n        s4: sample4,\n        s5: sample5\n      });\n      var operand = this.state.blockPricingOperand;\n      var pricingInput1 = this.state.blockPricingInput1 == \"#\" ? \"#\" : parseFloat(this.state.blockPricingInput1);\n      var pricingInput2 = this.state.blockPricingInput2 == \"#\" ? \"#\" : parseFloat(this.state.blockPricingInput2);\n      var startingPrice = parseFloat(this.state.startingPrice);\n      var tokensPerBlock = parseInt(this.state.tokensPerBlock);\n\n      function getCost(blockNumber) {\n        console.log(\"Block #: \", blockNumber);\n        console.log(\"Input 1: \", pricingInput1);\n        console.log(\"operand: \", operand);\n        console.log(\"Input 2: \", pricingInput2);\n        console.log(\"Starting price: \", startingPrice);\n        console.log(\"tokens per block: \", tokensPerBlock);\n        var adjustment = 0;\n\n        switch (operand) {\n          case \"*\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber * pricingInput2;\n            } else {\n              adjustment = pricingInput1 * blockNumber;\n            }\n\n            break;\n\n          case \"^\":\n            if (pricingInput1 == \"#\") {\n              adjustment = Math.pow(blockNumber, pricingInput2);\n            } else {\n              adjustment = Math.pow(pricingInput1, blockNumber);\n            }\n\n            break;\n\n          case \"+\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber + pricingInput2;\n            } else {\n              adjustment = pricingInput1 + blockNumber;\n            }\n\n            break;\n\n          case \"-\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber - pricingInput2;\n            } else {\n              adjustment = pricingInput1 - blockNumber;\n            }\n\n            break;\n\n          case \"/\":\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber / pricingInput2;\n            } else {\n              adjustment = pricingInput1 / blockNumber;\n            }\n\n            break;\n\n          default:\n            if (pricingInput1 == \"#\") {\n              adjustment = blockNumber * pricingInput2;\n            } else {\n              adjustment = pricingInput1 * blockNumber;\n            }\n\n            break;\n        }\n\n        var blockCost = startingPrice * tokensPerBlock * adjustment;\n        return blockCost;\n      }\n\n      this.setState({\n        s1BlockCost: getCost(1),\n        s2BlockCost: getCost(sample2),\n        s3BlockCost: getCost(sample3),\n        s4BlockCost: getCost(sample4),\n        s5BlockCost: getCost(sample5)\n      });\n      var targetPrice = parseInt(this.state.potentialInvestors) > 5 ? 5 * parseFloat(this.state.s5BlockCost) * parseFloat(this.state.minimumReturn) : parseInt(this.state.potentialInvestors) * parseFloat(this.state.s5BlockCost) * parseFloat(this.state.minimumReturn);\n    });\n\n    _defineProperty(this, \"onSubmit\", async event => {\n      event.preventDefault();\n      this.setState({\n        loading: true,\n        errorMessage: \"\"\n      });\n\n      try {\n        const accounts = await web3.eth.getAccounts();\n        await tokenMintFactory.methods.createToken(this.state.tokenName, this.state.tokenSymbol, this.state.wholeTokens, this.state.decimals).send({\n          from: accounts[0]\n        });\n        Router.pushRoute(\"/funding\");\n      } catch (err) {\n        this.setState({\n          errorMessage: err.message\n        });\n      }\n\n      this.setState({\n        loading: false\n      });\n    });\n  }\n\n  render() {\n    return __jsx(Layout, {\n      page: \"create\"\n    }, __jsx(Grid, null, __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h2\", null, \"Create a Mintable ERC-20 Token\"))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h3\", null, \"Token Details\"))), __jsx(Form, {\n      onSubmit: this.onSubmit,\n      error: !!this.state.errorMessage\n    }, __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n      widths: \"equal\"\n    }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Token Name\"), __jsx(Input, {\n      value: this.state.tokenName,\n      onChange: event => this.setState({\n        tokenName: event.target.value\n      })\n    })), __jsx(Form.Field, null, __jsx(\"label\", null, \"Token Symbol\"), __jsx(Input, {\n      value: this.state.tokenSymbol,\n      onChange: event => this.setState({\n        tokenSymbol: event.target.value\n      })\n    }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n      widths: \"equal\"\n    }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Decimals\"), __jsx(Input, {\n      value: this.state.decimals,\n      onChange: event => this.setState({\n        decimals: event.target.value\n      })\n    })), __jsx(Form.Field, null, __jsx(\"label\", null, \"Tokens Per Block\"), __jsx(Input, {\n      value: this.state.tokensPerBlock,\n      onChange: event => this.setState({\n        tokensPerBlock: event.target.value\n      })\n    }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Message, {\n      error: true,\n      header: \"Oops!\",\n      content: this.state.errorMessage\n    }), __jsx(\"br\", null)))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h3\", null, \"Profit Calculator\"))), __jsx(Form, {\n      onSubmit: this.calculate,\n      error: !!this.state.calculateErrorMessage\n    }, __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n      widths: \"equal\"\n    }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Potential Investors\"), __jsx(Input, {\n      value: this.state.potentialInvestors,\n      onChange: event => this.setState({\n        potentialInvestors: event.target.value\n      })\n    }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n      widths: \"equal\"\n    }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Projected Profits\"), __jsx(Input, {\n      label: \"ether\",\n      labelPosition: \"right\",\n      value: this.state.projectedProfits,\n      onChange: event => this.setState({\n        projectedProfits: event.target.value\n      })\n    })), __jsx(Form.Field, null, __jsx(\"label\", null, \"% of Profits to Pool\"), __jsx(Input, {\n      label: \"%\",\n      labelPosition: \"right\",\n      value: this.state.initialPoolPercentage,\n      onChange: event => this.setState({\n        initialPoolPercentage: event.target.value\n      })\n    }))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n      widths: \"equal\"\n    }, __jsx(Form.Field, null, __jsx(\"label\", null, \"Minimum Return\"), __jsx(Input, {\n      label: \"X\",\n      labelPosition: \"right\",\n      value: this.state.minimumReturn,\n      onChange: event => this.setState({\n        minimumReturn: event.target.value\n      })\n    })), __jsx(Form.Field, null, __jsx(\"label\", null, \"Blocks to Stabilize\"), __jsx(Input, {\n      value: this.state.blocksToStabilize,\n      onChange: event => this.setState({\n        blocksToStabilize: event.target.value\n      })\n    }))), __jsx(\"br\", null))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Form.Group, {\n      inline: true\n    }, __jsx(Form.Field, {\n      label: \"Mint Fee Pricing:\",\n      control: \"select\",\n      value: this.state.blockPricingInput1,\n      onChange: event => this.setState({\n        blockPricingInput1: event.target.value,\n        blockPricingInput2: event.target.value != \"#\" ? \"#\" : this.state.blockPricingInput2\n      })\n    }, __jsx(\"option\", {\n      value: \"#\"\n    }, \"Number of Blocks\"), __jsx(\"option\", {\n      value: \"0.5\"\n    }, \"0.5\"), __jsx(\"option\", {\n      value: \"1\"\n    }, \"1\"), __jsx(\"option\", {\n      value: \"2\"\n    }, \"2\"), __jsx(\"option\", {\n      value: \"3\"\n    }, \"3\"), __jsx(\"option\", {\n      value: \"4\"\n    }, \"4\"), __jsx(\"option\", {\n      value: \"5\"\n    }, \"5\"), __jsx(\"option\", {\n      value: \"6\"\n    }, \"6\"), __jsx(\"option\", {\n      value: \"7\"\n    }, \"7\"), __jsx(\"option\", {\n      value: \"8\"\n    }, \"8\"), __jsx(\"option\", {\n      value: \"9\"\n    }, \"9\"), __jsx(\"option\", {\n      value: \"10\"\n    }, \"10\"), __jsx(\"option\", {\n      value: \"20\"\n    }, \"20\"), __jsx(\"option\", {\n      value: \"30\"\n    }, \"30\"), __jsx(\"option\", {\n      value: \"40\"\n    }, \"40\"), __jsx(\"option\", {\n      value: \"50\"\n    }, \"50\"), __jsx(\"option\", {\n      value: \"60\"\n    }, \"60\"), __jsx(\"option\", {\n      value: \"70\"\n    }, \"70\"), __jsx(\"option\", {\n      value: \"80\"\n    }, \"80\"), __jsx(\"option\", {\n      value: \"90\"\n    }, \"90\"), __jsx(\"option\", {\n      value: \"100\"\n    }, \"100\"), __jsx(\"option\", {\n      value: \"200\"\n    }, \"200\"), __jsx(\"option\", {\n      value: \"300\"\n    }, \"300\"), __jsx(\"option\", {\n      value: \"400\"\n    }, \"400\"), __jsx(\"option\", {\n      value: \"500\"\n    }, \"500\"), __jsx(\"option\", {\n      value: \"600\"\n    }, \"600\"), __jsx(\"option\", {\n      value: \"700\"\n    }, \"700\"), __jsx(\"option\", {\n      value: \"800\"\n    }, \"800\"), __jsx(\"option\", {\n      value: \"900\"\n    }, \"900\"), __jsx(\"option\", {\n      value: \"1000\"\n    }, \"1000\")), __jsx(Form.Field, {\n      control: \"select\",\n      value: this.state.blockPricingOperand,\n      onChange: event => this.setState({\n        blockPricingOperand: event.target.value\n      })\n    }, __jsx(\"option\", {\n      value: \"*\"\n    }, \"*\"), __jsx(\"option\", {\n      value: \"^\"\n    }, \"^\"), __jsx(\"option\", {\n      value: \"+\"\n    }, \"+\"), __jsx(\"option\", {\n      value: \"-\"\n    }, \"-\"), __jsx(\"option\", {\n      value: \"/\"\n    }, \"/\")), __jsx(Form.Field, {\n      control: \"select\",\n      value: this.state.blockPricingInput2,\n      onChange: event => this.setState({\n        blockPricingInput2: event.target.value,\n        blockPricingInput1: event.target.value != \"#\" ? \"#\" : this.state.blockPricingInput1\n      })\n    }, __jsx(\"option\", {\n      value: \"#\"\n    }, \"Number of Blocks\"), __jsx(\"option\", {\n      value: \"0.5\"\n    }, \"0.5\"), __jsx(\"option\", {\n      value: \"1\"\n    }, \"1\"), __jsx(\"option\", {\n      value: \"2\"\n    }, \"2\"), __jsx(\"option\", {\n      value: \"3\"\n    }, \"3\"), __jsx(\"option\", {\n      value: \"4\"\n    }, \"4\"), __jsx(\"option\", {\n      value: \"5\"\n    }, \"5\"), __jsx(\"option\", {\n      value: \"6\"\n    }, \"6\"), __jsx(\"option\", {\n      value: \"7\"\n    }, \"7\"), __jsx(\"option\", {\n      value: \"8\"\n    }, \"8\"), __jsx(\"option\", {\n      value: \"9\"\n    }, \"9\"), __jsx(\"option\", {\n      value: \"10\"\n    }, \"10\"))))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Button, {\n      color: \"teal\",\n      style: {\n        marginBottom: \"20px\"\n      }\n    }, \"Calculate\")))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(\"h3\", null, \"Summary:\"), __jsx(\"p\", null, \"This mint fee of\", \" \", __jsx(\"strong\", null, \"(\", this.state.blockPricingInput1 == \"#\" ? \"Block #\" : this.state.blockPricingInput1, \" \", this.state.blockPricingOperand, \" \", this.state.blockPricingInput2 == \"#\" ? \"Block #\" : this.state.blockPricingInput2, \")\"), \" \", \"will be in effect for the first\", \" \", __jsx(\"strong\", null, this.state.blocksToStabilize, \" blocks (\", this.state.coinsToStabilize, \" tokens)\"), \".\"), __jsx(\"p\", null, \"The price will stabilize at \", __jsx(\"strong\", null, \"xxx.xx ether\"), \" per token with a stable mint fee of \", __jsx(\"strong\", null, \"xxx.xx ETH\"), \".\"), __jsx(\"p\", null, \"Assuming \", __jsx(\"strong\", null, this.state.initialPoolPercentage, \"%\"), \" of profits of \", __jsx(\"strong\", null, this.state.projectedProfits, \" ether\"), \" \", \"are contributed to the liquidity pool:\"))), __jsx(Grid.Row, null, __jsx(Grid.Column, null, __jsx(Table, {\n      celled: true\n    }, __jsx(Table.Header, null, __jsx(Table.Row, null, __jsx(Table.HeaderCell, null, \"Block\"), __jsx(Table.HeaderCell, null, \"Cost\"), __jsx(Table.HeaderCell, null, \"Blocks to Break Even\"), __jsx(Table.HeaderCell, null, \"Blocks to \", this.state.minimumReturn, \"X\"))), __jsx(Table.Body, null, __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #1\"), __jsx(Table.Cell, null, this.state.s1BlockCost, \" ETH\"), __jsx(Table.Cell, null, this.state.s1BlocksToProfit), __jsx(Table.Cell, null, \"xxx\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s2), __jsx(Table.Cell, null, this.state.s2BlockCost, \" ETH\"), __jsx(Table.Cell, null, this.state.s2BlocksToProfit), __jsx(Table.Cell, null, \"xxx\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s3), __jsx(Table.Cell, null, this.state.s3BlockCost, \" ETH\"), __jsx(Table.Cell, null, this.state.s3BlocksToProfit), __jsx(Table.Cell, null, \"xxx\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s4), __jsx(Table.Cell, null, this.state.s4BlockCost, \" ETH\"), __jsx(Table.Cell, {\n      negative: true\n    }, this.state.s4BlocksToProfit), __jsx(Table.Cell, {\n      negative: true\n    }, \"Too Many\")), __jsx(Table.Row, null, __jsx(Table.Cell, null, \"Block #\", this.state.s5), __jsx(Table.Cell, null, this.state.s5BlockCost, \" ETH\"), __jsx(Table.Cell, {\n      negative: true\n    }, this.state.s5BlocksToProfit), __jsx(Table.Cell, {\n      negative: true\n    }, \"Too Many\"))))))), __jsx(\"br\", null));\n  }\n\n}\n\nexport default TokenMintNew;","map":null,"metadata":{},"sourceType":"module"}